#pragma kernel CSMain

#define WIDTH   128
#define HEIGHT  512

#define EVAPORATION_THRESHOLD 5

#define LEVEL_MASK  0x00ff
#define SOURCE_MASK 0x0100
#define WALL_MASK   0x0200
#define FLOW_MASK   0x0C00

#define TOP     0
#define BOTTOM  1
#define LEFT    2
#define RIGHT   3

RWStructuredBuffer<uint> Result;

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint index = WIDTH * id.y + id.x;
    uint centerValue = Result[index];

    uint centerLevel = centerValue & LEVEL_MASK;
    if (centerLevel < EVAPORATION_THRESHOLD) {
        Result[index] = 0;
        return;
    }

    if (centerValue & WALL_MASK) {
        return;
    }

    uint values[4] = {
        id.y > 0 ?      Result[index -  WIDTH] : 0, // TOP
        id.y < HEIGHT ? Result[index +  WIDTH] : 0, // BOTTOM
        id.x > 0 ?      Result[index -      1] : 0, // LEFT
        id.x < WIDTH ?  Result[index +      1] : 0, // RIGHT
    };

    uint flow = (centerValue & FLOW_MASK) >> 10;
    uint directions[4];
    directions[0] = flow;
    for (uint i = 0; i < 3; ++i) {
        directions[i + 1] = i < flow ? i : i + 1;
    }

    while (true) {
        uint changed = 0;
        for (i = 0; i < 4 && centerLevel > 0; ++i) {
            uint value = values[directions[i]];

            uint level = value & LEVEL_MASK;
            if (!(value & WALL_MASK) && level < centerLevel) {
                changed = 1;
                uint delta = min(min(10, 255 - level), centerLevel);

                level += delta;
                centerLevel -= delta;
                values[directions[i]] = (directions[i] << 10) | (level & LEVEL_MASK);
            }
        }

        if (!changed) {
            break;
        }
    }

    Result[index -  WIDTH] = values[TOP];
    Result[index +  WIDTH] = values[BOTTOM];
    Result[index -      1] = values[LEFT];
    Result[index +      1] = values[RIGHT];
    Result[index] = centerLevel & LEVEL_MASK;
}
